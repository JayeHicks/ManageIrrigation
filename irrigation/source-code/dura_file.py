""" 
Jaye Hicks 2020

Obligatory legal disclaimer:
  You are free to use this source code (this file and all other files 
  referenced in this file) "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THIS SOURCE CODE
  IS WITH YOU.  SHOULD THE SOURCE CODE PROVE DEFECTIVE, YOU ASSUME THE
  COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. See the GNU 
  GENERAL PUBLIC LICENSE Version 3, 29 June 2007 for more details.

Objects of type dura_file can be used to read and write specially
formatted files with the additional ability of determing the file's
integrity.  These files follow a precise format:

{"hash_info" : {}, "data" : {}}

In this file format, the data to the right of the "hash_info" key
is the overhead introduced and used by the dura_file class.  Data
to the right of the "data" key is flat file's actual content that
is supplied by and used by the end user.  The specially formated
files can only be created, read, and modified by an object of type
dura_file.

An dura_file object can create a file on one platform (e.g., PI 4),
be transmitted over an arbitrary network (e.g., Internet), and then
validated/used on a second platform (e.g., AWS Lambda service).  The
functionaltiy provided by dura_file enables the recipient of a data
communication transfer to be reasonably certain that the file that
was received is complete and uncorrupted.  Data hashing is used to
implement dura_file functionality but take note that you cannot use
the Python built-in function 'hash' as the hash value it generates
for a given input will vary from platform to platorm.  The hash 
values generated by dura_class are consistant across all platforms
(e.g., Windows, Linux, AWS Lambda service)

"""
class dura_file():
  """
  Usage:
    End users create a dura_file object and then use it to write date
    and read data from specially formatted files.  A dura_file object
    can also be used to validate that the data to the right of the
    "data" key in a specially formatted file is complete and unchanged
    relative to when the file was created.  End user modification of
    a specially formatted file will cause issues.
  
    >> import dura_file
    >> df = dura_file.dura_file()
    >> df.write_data('test.json', {'test' : 'test value'})
    >> df.file_valid('test.json')
    True
    >> data = df.read_data('test.json')
    {'test' : 'test-value'}

  Details: as the sha256 hash algorithm is supported on most platforms
    it was selected for use by dura_file.  The Python built-in function
    hash will generate different values across different platforms and
    different installations of Python on the same platform.
    
    The hash value stored in the specially formatted flat files used by
    dura_file are the values returned by hashlib.hexdigest()
  """
  import logging
  import sys
  import hashlib
  import json
  from   pathlib import Path


  def __init__(self):
    self.logger = self.logging.getLogger(__name__)
    self.logger.info('entering: __init__()')


  def file_valid(self, file_name):
    """
    The dura_file class operates on specially formatted files, enabling
    reasonable certainty that the data contained within a file is both
    complete and uncorrupt. The files that dura_file works with must
    follow an exact format: {"hash_info" : {}, "data" : {}}.  The
    JSON object may contain additional key value pairs at the root
    level and they will be ignored by dura_file functionality.  
    dura_file only works on the data contained on the value side of 
    the root key named "data"
    
    Args:
      file_name(str)  <file name> or <path + file name>
    
    Returns:
      None   file does not exist
      True   validated the value side of "data" key
      False  issue accessing file, bad JSON, or issue obtaining hash
    """
    self.logger.info('entering: file_valid()')

    result   = None
    the_file = self._file_exists(file_name)
    if(the_file == False):
      self.logger.error(f'1 The file: {file_name} does not exist')
    elif(the_file  == None):
      result = False 
    else:
      json_object = self._extract_file_contents(file_name)   
      if(json_object):
        try:
          supplied_hash = json_object['hash_info']['hash_value']
        except Exception as e:
          result = False
          self.logger.error(f'2 Invalid / damaged JSON object. Exception: {e}')
        else:
          generated_hash = self._hash_data(json_object=json_object)
          if(generated_hash):
            if(supplied_hash == generated_hash):
              result = True
            else:
              result = False
          else:
            result = generated_hash
      else:
        result = json_object
    return(result)

  
  def read_data(self, file_name):
    """
    The dura_file class is designed to work with specially formatted
    flat files.  This function returns the data to the right of the 
    key "data" within a specially formatted file.

    Args:
      file_name(str)  <filename> or <path + file name>

    Returns:
      None   the file does not exist
      False  issue occuring trying to read the file
      <{}>   the JSON object on value side of "data" key
    """
    self.logger.info('entering: read_data()')

    data = None
    the_file = self._file_exists(file_name)
    if(the_file == False):
      self.logger.error(f'3 The file: {file_name} does not exist.')
    elif(the_file  == None):
      data = False 
    else:
      json_object = self._extract_file_contents(file_name)
      if(json_object):
        try:
          data = json_object['data']
        except Exception as e:
          data = False
          self.logger.error(f'4 Invalid JSON object. Exception: {e}')
      else:
        data = json_object
    return(data)
      
    
  def write_data(self, file_name, json_object):
    """
    Create a file or overwrite an existing file.  Write the data
    contained in the json_object parameter into this file following
    a special file format required by the class dura_file.  That is,
    {"hash_info": {}, "data" : {}}.  The input parameter is inserted
    as the value of the "data" key

    The data to the right of the "data" is fed to sha256 to generate a 
    hexdigest (i.e., a hex encoded string representing the hash value 
    generated on this data)

    Any preexisting file in the same directory with the same file name
    will be over written
    
    Args:
      file_name(str)         <file name> or <path + file name>

      json_object(str/dict)  string or Python dict representing the
                             data to the right of the "data" key in
                             the special file format 
    Returns:
      None      issue before file write attempt (e.g., hash function)
      True      file write succeeded
      False     file write failed
    """
    self.logger.info('entering: write_data()')

    results = None
    if((((type(json_object) != str) and (type(json_object) != dict)) or
        (type(file_name) != str)) or
        ((not json_object) or (not file_name))):
      self.logger.error('5 Invalid parameter type or value')
    else:
      json_staging_obj = {
        'hash_info' : { 
          'algorithm' : 'sha256',
          'format' : 'hexdigest',
          'hash_value' : ''},
        'data' : {}}
      if(type(json_object) == dict):
        try:
          json_staging_obj['data'] = json_object
        except Exception as e:
          self.logger.error(f'6 Malformed dict parameter. Exception:{e}')
      else:
        try:
          data_as_json = self.json.loads(json_object)
          json_staging_obj['data'] = data_as_json
        except Exception as e:
          self.logger.error(f'7 Malformed str json_object parameter {e}')
          
      if(json_staging_obj['data']):
        try:
          data_as_string = self.json.dumps(json_staging_obj['data'])
          hash_value_object = self.hashlib.sha256(data_as_string.encode())
          hash_value = hash_value_object.hexdigest()
          json_staging_obj['hash_info']['hash_value'] = hash_value
          try:
            with open(file_name, 'w+') as data_file:
              try:
                self.json.dump(json_staging_obj, data_file)
                self.sys.stdout.flush()
                results = True
              except Exception as e:
                results = False
                self.logger.error('8 Could not save JSON object to file. ' +
                                  f'Exception: {e}')
          except Exception as e:
            results = False
            self.logger.error(f'9 Could not open file: {file_name}. ' +
                              f'Exception {e}')
        except Exception as e:
          self.logger.error(f'10 Could not hash data. Exception: {e}')
    return(results)


  def _file_exists(self, file_name):
    """
    args:
      file_name(str)  <file name> or <path + file name>

    returns:
      None         error occured before / during existance test
      True         test revealed that file exists
      False        test revealted that file does not exist
    """
    self.logger.info('entering: _file_exists()')

    exists = None
    if((not file_name) or (type(file_name) != str)):
      self.logger.error('11 Invalid value specified for <path + filename>')
    else:
      try:
        exists = self.Path(file_name).is_file()
      except Exception as e:
        exists = None
        self.logger.error('12 Exception thrown by pathlib() module. ' +
                          f'Exception: {e}') 
    return(exists)


  def _extract_file_contents(self, file_name):
    """
    The dura_file class works with specially formatted files that
    follow a strict format.  This funciton returns the data to the
    right of the "data" key.  
    
    Args:
      file_name (str)   name of file
    
    Returns:
      None    file does not exist
      {}      Ptyhon dictionary; file contents to right of the key "data"
      False   file access failed or bad JSON
    """
    self.logger.info('entering: _extract_file_contents()')

    json_object = None
    the_file = self._file_exists(file_name)
    if(the_file == False):
      self.logger.error(f'13 The file: {file_name} does not exist.')
    elif(the_file == None):
      json_object = False 
    else:
      try:
        with open(file_name) as data_file:
          try:
            json_object = self.json.load(data_file)  
          except Exception as e:
            json_object = False
            self.logger.error('14 Could not extract JSON object from file. ' +
                              f'Exception: {e}')
      except Exception as e:
        json_object = False
        self.logger.error(f'15 Could not open file. Exception: {e}')
    return(json_object)  
  
  
  def check_object(self, json_object='', file_name=''):
    """
    The dura_file class relies on specially formatted file structure.
    This processes 'json_object' or 'file_name' with the parmater
    'file_name' taking precedence if both are passed in.  The 
    preexisting hash value contained within the input parameter is 
    checked against a hash value generated by this function in order
    to detect a match or mismatch.

    Args:
      json_object (str/dict)   str or dict representing JSON object
      file_name (str)          Name of file containing JSON object
      
    Returns:
      None    issue before hash comparision could be made
      True    test made and hash in file == dynamically generated hash
      False   test made and hash in file != dynamically generated hash
    """
    self.logger.info('entering: check_object()')

    result = None
    if(((type(json_object) != str) and (type(json_object) != dict) and
        (type(file_name) != str)) or
       ((not json_object) and (not file_name))):
      self.logger.error('16 Invalid parameter type or value')
    else:
      if((file_name) and (type(file_name) == str)):
        json_object = self._extract_file_contents(file_name)   
      elif((json_object) and (type(json_object) == str)):
        try:
          json_object = self.json.loads(json_object)
        except Exception as e:
          self.logger.error('17 String parameter representing JSON object ' +
                            f'is invalid. Exception: {e}')
          json_object = False
      elif((json_object) and (type(json_object) == dict)):
        pass
      else:
        self.logger.error('18 Invalid parameter type or value')
      
      if(json_object):  # could have come from file, str, or dict
        try:
          supplied_hash = json_object['hash_info']['hash_value']
        except Exception as e:
          self.logger.error('19 Invalid or damaged JSON object. ' +
                            f'Exception: {e}')
        else:
          generated_hash = self._hash_data(json_object=json_object)
          if(generated_hash):
            if(supplied_hash == generated_hash):
              result = True
            else:
              result = False
      else:
        result = None
    return(result)


  def hash_string(self, string):
    """
    Hash an arbitrary string using sha256 and return the hexdigest
    which is a hex encoded string representing the hash result
    
    Args:
      string (str)        the input string to hash
    
    Returns:
      None                issue before hash attempt (e.g., bad params)
      <hash_value> (str)  hex encoded string representing hash value
      False               error attempting to hash string
    """
    self.logger.info('entering: hash_string()')

    hash_value = None
    if((string) and (type(string) == str)):
      try:
        hash_object = self.hashlib.sha256(string.encode())
        hash_value = hash_object.hexdigest()
      except Exception as e:
        hash_value = False
        self.logger.error(f'20 Could not hash data. Exception: {e}')
    else:
      self.logger.error('21 Invalid value supplied for input parameter')
    return(hash_value)
  
  
  def _hash_data(self, json_object='', file_name=''):
    """
    The dura_file class works with JSON objects that follow a special
    format.  This function will generate a hash value for either a
    json_object parameter or a file_name parameter, with precedence 
    given to the file_name parameter if both are present.
    
    The input parameter is accessed and the value to the right of the
    key "data" is extracted and fed to the SHA256 hashing algorithm to
    generate a hexdigest (i.e., a hex encoded string representing the 
    hash value generated on the input data).
        
    Args:
      json_object (str/dict)   str or dict representing JSON object
      file_name (str)          name of file containing JSON object
    
    Returns:
      None                file does not exist
      False               bad input parms or bad JSON or issue 
                            accessing file or hash failure
      <hash_value> (str)  hex encoded string of the hash value
    """
    self.logger.info('entering: _hash_data()')

    hash_value = None
    if(((type(json_object) != str) and (type(json_object) != dict) and
        (type(file_name) != str)) or
       ((not json_object) and (not file_name))):
      self.logger.error('22 Invalid parameter type or value')
      hash_value = False
    else:
      #precedence is given to 'file_name' parameter
      if((file_name) and (type(file_name) == str)):
        json_object = self._extract_file_contents(file_name) 
      elif((json_object) and (type(json_object) == str)):
        try:
          json_object = self.json.loads(json_object)
        except Exception as e:
          self.logger.error(f'23 Invalid JSON obj parameter. Exception: {e}')
          json_object = False
      elif((json_object) and (type(json_object) == dict)):
        pass
      else:
        self.logger.error('24 Invalid type or value for parameter(s)')

      if(json_object): # JSON can come from file, str, or dict
        try:
          data = json_object['data']
        except Exception as e:
          hash_value = False
          self.logger.error('25 Invalid or damaged JSON object. ' +
                            f'Exception: {e}')
        else:
          try:
            data_as_string = self.json.dumps(data)
            hash_value_object = self.hashlib.sha256(data_as_string.encode())
            hash_value = hash_value_object.hexdigest()
          except Exception as e:
            hash_value = False
            self.logger.error(f'26 Could not hash data. Exception: {e}')
      else: 
        hash_value = json_object
    return(hash_value)