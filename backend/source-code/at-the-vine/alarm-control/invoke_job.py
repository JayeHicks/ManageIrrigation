""" 
Jaye Hicks 2020

Obligatory legal disclaimer:
  You are free to use this source code (this file and all other files 
  referenced in this file) "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THIS SOURCE CODE
  IS WITH YOU.  SHOULD THE SOURCE CODE PROVE DEFECTIVE, YOU ASSUME THE
  COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. See the GNU 
  GENERAL PUBLIC LICENSE Version 3, 29 June 2007 for more details.
  
This module serves as an AWS Lambda function.  It will be invoked
ad hoc, via a service integration with a single API Gateway API
in order to enable invocation of Absence Guard, Battery Guard, 
Freeze Guard, or Moisture Guard from the Control Sensors / Alarms
single page web application.

Usage: 
  The single page web application Contorl Sensors / Alarms provides
  buttons that an end user can select to invoke various guards. 
  
  This module is invoked on an ad hoc basis

Informational and error messages generated by this module, and other 
Python modules that work with this raw vineyard sensor data (e.g., 
ingestion, life cycle management, freeze/battery/absence guard), are 
stored in two DynamoDB tables.  Messages stored in the table for errors, 
table_name_1, will not automatically expire and require 
manual data lifecycle management. Messages stored in the the table for 
informational missives, table_name_2, are inserted with a 
TTL value and are therefore automatically purged after reaching a 
certain age.

Dependencies:
  import boto3
  import json
  import time
  from datetime import datetime, timedelta
"""
import boto3
import json
import time
from datetime import datetime, timedelta

ALL_JOBS = ['absence_guard', 'archive_check', 'archive_data', 'battery_guard',
            'delete_data', 'freeze_guard', 'moisture_guard', 'pull_data', 
            'update_status']
GUARDS = ['absence_guard', 'battery_guard', 'freeze_guard', 'moisture_guard']

JOB                 = 'invoke_job'
ERROR               = 1
ALARM               = 2
INFO                = 3
WARN                = 4
error_messages      = {}
info_messages       = {}
       
       
def _write_logs_to_databases():
  """
  As part of the backend management / processing of vineyard sensor 
  stations raw data, messages are recorded to DynamoDB tables by the
  various Python jobs that ingest and curate the data.  Informational
  message have a TTL, error messages do not and require manual curation.
  Due to low volume, a batch writer to insert messages not needed.
  """
  try:
    dynamo_db_access = boto3.resource('dynamodb')
    if(error_messages):
      try:
        table = dynamo_db_access.Table('table_name_1')
        for key, value in error_messages.items():
          table.put_item(Item={'date' : value['date'], 
                               'stamp_job' : key,
                               'message': value['message']})
      except:
        pass  #where do you log when logging doesn't work?
    if(info_messages):
      try:
        table = dynamo_db_access.Table('table_name_2')
        for key, value in info_messages.items():
          table.put_item(Item={'date': value['date'],
                               'stamp_job' : key, 
                               'message': value['message'], 
                               'expiry' : value['expiry']})
      except:
        pass #where do you log when logging doesn't work?
  except:
    pass #where do you log when logging doesn't work?
  
  
def _log_message(position, type, message, exception):
  """
  As part of the backend management / processing of vineyard sensor 
  stations raw data, messages are recorded to DynamoDB tables.  As
  the epoch timestamp used is in seconds, vs milliseconds, the 1
  second delay is used to avoid sort key clashes.  Wont be a performance
  issue as this funciton is called infrequently.
  
  Note: 2038 epoch time roll over issue
  """    
  time.sleep(1)
  now = datetime.now()
  timestamp = int(now.timestamp()) #converts millisecons to seconds
  cst = now - timedelta(hours=6)   #UTC to US Central Std
  date = str(cst.year) + '-' + str(cst.month).zfill(2) + '-' 
  date += str(cst.day).zfill(2)
  stamp_job = str(timestamp) + '+' + JOB
  prefix = ['','ERROR: (','ALARM: (','INFO: (','WARN: (']
    
  log_message = prefix[type] + position + ') ' + message + ' '  
  if(exception):
    try:
      if(exception.response['Error']['Message']):
        log_message += exception.response['Error']['Message']
      else:
        log_message += str(exception)
    except:
      log_message += str(exception)
  
  if((type == ERROR) or (type == ALARM)):
    error_messages[stamp_job] = {'date' : date, 'message' : log_message}
  else:
    expiration = timestamp + 5184000   #DynamoDB autodelete in 2 months
    info_messages[stamp_job] = {'date' : date, 'message' : log_message,
                                'expiry' : expiration}
                                
                         
def invoke_job(event, context):                  
  """
  Args (supplied by AWS Lambda service)
    event: information about who/what invoked the Lambda function
    context: information about the Lambda function's runtime environment
  """
  #necessary as Lambda service caches globals between function invocations
  global error_messages
  error_messages  = {}
  global info_messages
  info_messages  = {}
  
  if(event):
    job = event['job'].lower()
    if(job in GUARDS):
      try:
        lambda_access = boto3.client('lambda')  
        try:
          lambda_access.invoke(FunctionName = job, 
                                  InvocationType = 'Event')
        except Exception as e:
          _log_message('1', ERROR, '', e)
      except Exception as e:
        _log_message('2', ERROR, '', e)
    else:
      _log_message('3', ERROR, 'Invalid job name "' + job + '" specified.', '')
  else:
    _log_message('4', ERROR, 'Empty parameter to Lambda function.', '')
  
  if(error_messages):
    _log_message('5', WARN, 
      'The invoke_job process did not complete successfully.', '')
  else:
    _log_message('5', INFO,
      'The invoke_job process completed successfully.', '')
  
  _write_logs_to_databases()
  
  # API Gateway integration that invokes this module will use its own CORS 
  # and ignore these.  However, it does not harm to supply them and will
  # prove instructive if, in the future, a need arises to call this module
  # directly vs. through an API Gateway integraiton.  For future reference,
  # Access-Control-Allow-Headers is used for the OPTIONS method while
  # GET only requires the return of Access-Control-Allow-Origin
  return({'statusCode': 200,
          'headers': {'Access-Control-Allow-Headers': 'Content-Type,' +
                                                      'X-Amz-Date,' +
                                                      'Authorization,' +
                                                      'X-Api-Key,' +
                                                      'X-Amz-Security-Token',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Methods': 'OPTIONS,GET'},
          'body': json.dumps('all good here...')})